/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a role-based access control system for a school management application.
 *
 * Data Structure:
 * - /branches/{branchId}: Stores branch information.
 * - /users/{userId}: Stores user information including roles (teacher, parent, branch_admin, super_admin) and branch affiliations.
 * - /students/{studentId}: Stores student information, including parentUserId.
 * - /payments/{paymentId}: Stores payment information, denormalized with studentId, parentUserId, and branchId.
 * - /parentCredentials/{userId}: Stores temporary parent credentials, automatically deleted after a TTL.
 * - /attendance/{attendanceId}: Stores daily attendance records. Document ID is a composite of studentId and date.
 * - /subjects/{subjectId}: Stores all available subjects.
 * - /terms/{termId}: Stores all school terms.
 * - /results/{resultId}: Stores student results. The ID is a composite of studentId, termId, and subjectId.
 * - /notifications/{notificationId}: Stores notifications for users.
 *
 * Key Security Decisions:
 * - Access to user data is strictly controlled based on the user's role and branch affiliation.
 * - Super admins have full access to all data.
 * - Branch admins have access to data within their branch.
 * - Parents have access to their children's data.
 * - Teachers have access to student data within their branch.
 * - Listing of users is generally disallowed except for super admins.
 * - Default security posture for ambiguous relationships is strict owner-only access.
 *
 * Denormalization for Authorization:
 * - The 'Payment' entity denormalizes 'studentId', 'parentUserId', and 'branchId' to simplify security rules and avoid costly 'get()' calls.
 * - The 'Student' entity denormalizes 'branchId' and 'parentEmail' to simplify security rules and avoid costly 'get()' calls.
 * - The 'Attendance' entity denormalizes 'studentName', 'admissionNo', and 'branchId' to simplify security rules and avoid costly 'get()' calls.
 * - The 'Result' entity denormalizes 'studentName', 'termName', and 'subjectName' to simplify security rules and avoid costly 'get()' calls.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Manages access to branch information.
     * @path /branches/{branchId}
     * @allow (get, list): Public read access for all users.
     * @allow (create, update, delete): Only super admins can manage branches.
     * @deny (create, update, delete): Non-super admins cannot create, update, or delete branches.
     * @principle Role-based access control, public read access.
     */
    match /branches/{branchId} {
      allow get, list: if true;
      allow create, update, delete: if isSignedIn() && isAdmin();
    }

    /**
     * @description Manages access to user information.
     * @path /users/{userId}
     * @allow (get): Only the user themselves or a super admin can read user data.
     * @allow (list): Only super admins can list users.
     * @allow (create): Users can create their own user document, but must match their auth UID.
     * @allow (update, delete): Only the user themselves or a super admin can update/delete user data.
     * @deny (create): Creating a user with a userId that does not match request.auth.uid
     * @principle Ownership and role-based access control.
     */
    match /users/{userId} {
      allow get: if isSignedIn() && (isOwner(userId) || isAdmin());
      allow list: if isSignedIn() && isAdmin();
      allow create: if isSignedIn() && isSelfCreating(userId);
      allow update, delete: if isSignedIn() && (isOwner(userId) || isAdmin());
    }

    /**
     * @description Manages access to student information.
     * @path /students/{studentId}
     * @allow (get, list): Only users in the same branch, super admins, or the student's parent can read student data.
     * @allow (create): Only users with 'branch_admin' or 'super_admin' roles can create student records. The branchId must be consistent.
     * @allow (update, delete): Only users with 'branch_admin' or 'super_admin' roles can update or delete student records within the same branch.
     * @deny (create): Users that are not in the same branch or not branch_admin or super_admin.
     * @principle Role-based and branch-based access control.
     */
    match /students/{studentId} {
      allow get: if isSignedIn() && (isBranchAdminOrTeacher(resource.data.branchId) || isParentOfStudent(studentId, resource.data.branchId) || isAdmin());
      allow list: if isSignedIn() && (isBranchAdminOrTeacher(getBranchIdFromUser()) || isParentOfStudentByDocId(studentId) || isAdmin());
      allow create: if isSignedIn() && (isBranchAdmin() || isAdmin()) && request.resource.data.branchId == getBranchIdFromUser() && request.resource.data.createdByUserId == request.auth.uid;
      allow update, delete: if isSignedIn() && (isBranchAdmin() || isAdmin()) && isExistingBranchAdminOrTeacherForStudentBranch(resource.data.branchId);
    }

    /**
     * @description Manages access to payment information.
     * @path /payments/{paymentId}
     * @allow (get, list): Only branch admins, the parent of the student, or super admins can read payment data.
     * @allow (create): Only parents can create payment records for their children.
     * @allow (update): Only branch admins or super admins can update payment records.
     * @allow (delete): Only super admins can delete payment records.
     * @deny (create): User is not the parent of the student.
     * @principle Role-based and ownership-based access control, using denormalized fields.
     */
    match /payments/{paymentId} {
      allow get: if isSignedIn() && (isBranchAdminOrTeacher(resource.data.branchId) || isParentOfStudent(resource.data.studentId,resource.data.branchId) || isAdmin());
      allow list: if isSignedIn() && (isBranchAdminOrTeacher(getBranchIdFromUser()) || isParentOfStudent(resource.data.studentId,resource.data.branchId) || isAdmin());
      allow create: if isSignedIn() && isParentOfStudent(request.resource.data.studentId,request.resource.data.branchId) && request.auth.uid == request.resource.data.parentUserId;
      allow update: if isSignedIn() && (isBranchAdmin() || isAdmin());
      allow delete: if isSignedIn() && isAdmin();
    }

    /**
     * @description Manages access to parent credentials.
     * @path /parentCredentials/{userId}
     * @allow get: if false;
     * @allow list: if false;
     * @allow create: if isSignedIn() && isAdmin();
     * @allow update: if false;
     * @allow delete: if isSignedIn() && isAdmin() && resource != null;
     * @principle Only admins can manage parent credentials. Credentials are not directly readable via the rules.
     */
    match /parentCredentials/{userId} {
      allow get: if false;
      allow list: if false;
      allow create: if isSignedIn() && isAdmin();
      allow update: if false;
      allow delete: if isSignedIn() && isAdmin();
    }

    /**
     * @description Manages access to attendance records.
     * @path /attendance/{attendanceId}
     * @allow get: if isSignedIn() && (isBranchAdminOrTeacher(resource.data.branchId) || isParentOfStudent(resource.data.studentId, resource.data.branchId) || isAdmin());
     * @allow list: if isSignedIn() && (isBranchAdminOrTeacher(getBranchIdFromUser()) || isAdmin());
     * @allow create: if isSignedIn() && isTeacher() && request.resource.data.branchId == getBranchIdFromUser();
     * @allow update: if isSignedIn() && isTeacher() && resource.data.branchId == getBranchIdFromUser() && resource != null;
     * @allow delete: if false;
     * @principle Role-based access control. Teachers can only manage attendance for their branch. Parents can read only.
     */
    match /attendance/{attendanceId} {
      allow get: if isSignedIn() && (isBranchAdminOrTeacher(resource.data.branchId) || isParentOfStudent(resource.data.studentId, resource.data.branchId) || isAdmin());
      allow list: if isSignedIn() && (isBranchAdminOrTeacher(getBranchIdFromUser()) || isAdmin());
      allow create: if isSignedIn() && isTeacher() && request.resource.data.branchId == getBranchIdFromUser();
      allow update: if isSignedIn() && isTeacher() && resource.data.branchId == getBranchIdFromUser();
      allow delete: if false;
    }

    /**
     * @description Manages access to subjects.
     * @path /subjects/{subjectId}
     * @allow get, list: if true;
     * @allow create: if isSignedIn() && isAdmin();
     * @allow update: if isSignedIn() && isAdmin() && resource != null;
     * @allow delete: if isSignedIn() && isAdmin() && resource != null;
     * @principle Public read access, admin-only write access.
     */
    match /subjects/{subjectId} {
      allow get, list: if true;
      allow create: if isSignedIn() && isAdmin();
      allow update, delete: if isSignedIn() && isAdmin();
    }

    /**
     * @description Manages access to terms.
     * @path /terms/{termId}
     * @allow get, list: if true;
     * @allow create: if isSignedIn() && isAdmin();
     * @allow update: if isSignedIn() && isAdmin() && resource != null;
     * @allow delete: if isSignedIn() && isAdmin() && resource != null;
     * @principle Public read access, admin-only write access.
     */
    match /terms/{termId} {
      allow get, list: if true;
      allow create: if isSignedIn() && isAdmin();
      allow update, delete: if isSignedIn() && isAdmin();
    }

    /**
     * @description Manages access to results.
     * @path /results/{resultId}
     * @allow get, list: if isSignedIn() && (isBranchAdminOrTeacher(resource.data.branchId) || isParentOfStudent(resource.data.studentId, resource.data.branchId) || isAdmin());
     * @allow create: if isSignedIn() && isTeacher() && request.resource.data.recordedBy == request.auth.uid && request.resource.data.branchId == getBranchIdFromUser();
     * @allow update: if isSignedIn() && isTeacher() && resource.data.recordedBy == request.auth.uid  && resource != null;
     * @allow delete: if false;
     * @principle Role-based access control. Teachers can only manage results they created within their branch.
     */
    match /results/{resultId} {
      allow get: if isSignedIn() && (isBranchAdminOrTeacher(resource.data.branchId) || isParentOfStudent(resource.data.studentId, resource.data.branchId) || isAdmin());
      allow list: if isSignedIn() && (isBranchAdminOrTeacher(getBranchIdFromUser()) || isParentOfStudentByDocId(resource.data.studentId) || isAdmin());
      allow create: if isSignedIn() && isTeacher() && request.resource.data.recordedBy == request.auth.uid && request.resource.data.branchId == getBranchIdFromUser();
      allow update: if isSignedIn() && isTeacher() && resource.data.recordedBy == request.auth.uid;
      allow delete: if false;
    }

    /**
     * @description Manages access to notifications.
     * @path /notifications/{notificationId}
     * @allow get: if isSignedIn() && isOwner(resource.data.userId);
     * @allow list: if isSignedIn() && isOwner(resource.data.userId);
     * @allow create: if isSignedIn() && isAdmin();
     * @allow update: if isSignedIn() && isOwner(resource.data.userId) && resource != null;
     * @allow delete: if false; // Notifications should not be deleted by users
     * @principle User-based access control. Users can only access their own notifications.
     */
     match /notifications/{notificationId} {
        allow get: if isSignedIn() && isOwner(resource.data.userId);
        allow list: if isSignedIn() && isOwner(resource.data.userId);
        allow create: if isSignedIn() && isAdmin();
        allow update: if isSignedIn() && isOwner(resource.data.userId);
        allow delete: if false; // Notifications should not be deleted by users
    }
  }

  // Helper functions
  function isSignedIn() {
    return request.auth != null;
  }

  function isOwner(userId) {
    return request.auth.uid == userId;
  }

   function isSelfCreating(userId) {
    return request.auth.uid == userId;
  }

   function isExistingOwner(userId) {
    return isOwner(userId) && resource != null;
  }

  function isAdmin() {
    return isSignedIn() && request.auth.token.role == 'super_admin';
  }

  function isBranchAdmin() {
    return isSignedIn() && request.auth.token.role == 'branch_admin';
  }

  function isTeacher() {
    return isSignedIn() && request.auth.token.role == 'teacher';
  }

  function isParent() {
    return isSignedIn() && request.auth.token.role == 'parent';
  }

  function getBranchIdFromUser() {
    return request.auth.token.branchId;
  }

  function isBranchAdminOrTeacher(branchId) {
      return isSignedIn() && (isBranchAdmin() || isTeacher()) && getBranchIdFromUser() == branchId;
  }

  function isExistingBranchAdminOrTeacherForStudentBranch(branchId) {
      return isSignedIn() && (isBranchAdmin() || isTeacher()) && getBranchIdFromUser() == branchId && exists(/databases/$(database)/documents/branches/$(branchId));
  }

  function isParentOfStudent(studentId, studentBranchId) {
      return exists(/databases/$(database)/documents/students/$(studentId))
              && get(/databases/$(database)/documents/students/$(studentId)).data.parentUserId == request.auth.uid
              && get(/databases/$(database)/documents/students/$(studentId)).data.branchId == studentBranchId;
  }

  function isParentOfStudentByDocId(studentId) {
      return exists(/databases/$(database)/documents/students/$(studentId))
              && get(/databases/$(database)/documents/students/$(studentId)).data.parentUserId == request.auth.uid;
  }
}